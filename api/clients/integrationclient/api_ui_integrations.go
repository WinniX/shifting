/*
 * Integration API
 *
 * The Integration API allows apps to ...
 *
 * API version: v1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package integrationclient

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// UiIntegrationsApiService UiIntegrationsApi service
type UiIntegrationsApiService service

type ApiIntegrationUiIntegrationsByTargetByIdDeleteRequest struct {
	ctx _context.Context
	ApiService *UiIntegrationsApiService
	target string
	id string
}


func (r ApiIntegrationUiIntegrationsByTargetByIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IntegrationUiIntegrationsByTargetByIdDeleteExecute(r)
}

/*
 * IntegrationUiIntegrationsByTargetByIdDelete Method for IntegrationUiIntegrationsByTargetByIdDelete
 * <br>You must have this scope: 'integration:ui-integrations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param target
 * @param id
 * @return ApiIntegrationUiIntegrationsByTargetByIdDeleteRequest
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsByTargetByIdDelete(ctx _context.Context, target string, id string) ApiIntegrationUiIntegrationsByTargetByIdDeleteRequest {
	return ApiIntegrationUiIntegrationsByTargetByIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		target: target,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsByTargetByIdDeleteExecute(r ApiIntegrationUiIntegrationsByTargetByIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiIntegrationsApiService.IntegrationUiIntegrationsByTargetByIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/ui-integrations/{target}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", _neturl.PathEscape(parameterToString(r.target, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationUiIntegrationsByTargetByIdGetRequest struct {
	ctx _context.Context
	ApiService *UiIntegrationsApiService
	target string
	id string
}


func (r ApiIntegrationUiIntegrationsByTargetByIdGetRequest) Execute() (UiIntegrationItemModel, *_nethttp.Response, error) {
	return r.ApiService.IntegrationUiIntegrationsByTargetByIdGetExecute(r)
}

/*
 * IntegrationUiIntegrationsByTargetByIdGet Method for IntegrationUiIntegrationsByTargetByIdGet
 * <br>You must have this scope: 'integration:ui-integrations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param target
 * @param id
 * @return ApiIntegrationUiIntegrationsByTargetByIdGetRequest
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsByTargetByIdGet(ctx _context.Context, target string, id string) ApiIntegrationUiIntegrationsByTargetByIdGetRequest {
	return ApiIntegrationUiIntegrationsByTargetByIdGetRequest{
		ApiService: a,
		ctx: ctx,
		target: target,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return UiIntegrationItemModel
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsByTargetByIdGetExecute(r ApiIntegrationUiIntegrationsByTargetByIdGetRequest) (UiIntegrationItemModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UiIntegrationItemModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiIntegrationsApiService.IntegrationUiIntegrationsByTargetByIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/ui-integrations/{target}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", _neturl.PathEscape(parameterToString(r.target, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationUiIntegrationsByTargetByIdPutRequest struct {
	ctx _context.Context
	ApiService *UiIntegrationsApiService
	target string
	id string
	body *ReplaceUiIntegrationModel
}

func (r ApiIntegrationUiIntegrationsByTargetByIdPutRequest) Body(body ReplaceUiIntegrationModel) ApiIntegrationUiIntegrationsByTargetByIdPutRequest {
	r.body = &body
	return r
}

func (r ApiIntegrationUiIntegrationsByTargetByIdPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IntegrationUiIntegrationsByTargetByIdPutExecute(r)
}

/*
 * IntegrationUiIntegrationsByTargetByIdPut Method for IntegrationUiIntegrationsByTargetByIdPut
 * <br>You must have this scope: 'integration:ui-integrations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param target
 * @param id
 * @return ApiIntegrationUiIntegrationsByTargetByIdPutRequest
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsByTargetByIdPut(ctx _context.Context, target string, id string) ApiIntegrationUiIntegrationsByTargetByIdPutRequest {
	return ApiIntegrationUiIntegrationsByTargetByIdPutRequest{
		ApiService: a,
		ctx: ctx,
		target: target,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsByTargetByIdPutExecute(r ApiIntegrationUiIntegrationsByTargetByIdPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiIntegrationsApiService.IntegrationUiIntegrationsByTargetByIdPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/ui-integrations/{target}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", _neturl.PathEscape(parameterToString(r.target, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationUiIntegrationsByTargetByIdtestGetRequest struct {
	ctx _context.Context
	ApiService *UiIntegrationsApiService
	target string
	id string
}


func (r ApiIntegrationUiIntegrationsByTargetByIdtestGetRequest) Execute() (UiIntegrationTestResultModel, *_nethttp.Response, error) {
	return r.ApiService.IntegrationUiIntegrationsByTargetByIdtestGetExecute(r)
}

/*
 * IntegrationUiIntegrationsByTargetByIdtestGet Tests a private source integration.
 * Tests that the process of getting the public url from the provided url is done correctly.
If there are any errors with the process, it will provide information on what might have gone wrong.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param target Target for the integration
 * @param id Id of the integration to be tested
 * @return ApiIntegrationUiIntegrationsByTargetByIdtestGetRequest
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsByTargetByIdtestGet(ctx _context.Context, target string, id string) ApiIntegrationUiIntegrationsByTargetByIdtestGetRequest {
	return ApiIntegrationUiIntegrationsByTargetByIdtestGetRequest{
		ApiService: a,
		ctx: ctx,
		target: target,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return UiIntegrationTestResultModel
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsByTargetByIdtestGetExecute(r ApiIntegrationUiIntegrationsByTargetByIdtestGetRequest) (UiIntegrationTestResultModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UiIntegrationTestResultModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiIntegrationsApiService.IntegrationUiIntegrationsByTargetByIdtestGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/ui-integrations/{target}/{id}/$test"
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", _neturl.PathEscape(parameterToString(r.target, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationUiIntegrationsByTargetGetRequest struct {
	ctx _context.Context
	ApiService *UiIntegrationsApiService
	target string
}


func (r ApiIntegrationUiIntegrationsByTargetGetRequest) Execute() (UiIntegrationListModel, *_nethttp.Response, error) {
	return r.ApiService.IntegrationUiIntegrationsByTargetGetExecute(r)
}

/*
 * IntegrationUiIntegrationsByTargetGet Method for IntegrationUiIntegrationsByTargetGet
 * <br>You must have this scope: 'integration:ui-integrations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param target
 * @return ApiIntegrationUiIntegrationsByTargetGetRequest
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsByTargetGet(ctx _context.Context, target string) ApiIntegrationUiIntegrationsByTargetGetRequest {
	return ApiIntegrationUiIntegrationsByTargetGetRequest{
		ApiService: a,
		ctx: ctx,
		target: target,
	}
}

/*
 * Execute executes the request
 * @return UiIntegrationListModel
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsByTargetGetExecute(r ApiIntegrationUiIntegrationsByTargetGetRequest) (UiIntegrationListModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UiIntegrationListModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiIntegrationsApiService.IntegrationUiIntegrationsByTargetGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/ui-integrations/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", _neturl.PathEscape(parameterToString(r.target, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationUiIntegrationsByTargetPostRequest struct {
	ctx _context.Context
	ApiService *UiIntegrationsApiService
	target string
	body *CreateUiIntegrationModel
}

func (r ApiIntegrationUiIntegrationsByTargetPostRequest) Body(body CreateUiIntegrationModel) ApiIntegrationUiIntegrationsByTargetPostRequest {
	r.body = &body
	return r
}

func (r ApiIntegrationUiIntegrationsByTargetPostRequest) Execute() (UiIntegrationCreatedModel, *_nethttp.Response, error) {
	return r.ApiService.IntegrationUiIntegrationsByTargetPostExecute(r)
}

/*
 * IntegrationUiIntegrationsByTargetPost Method for IntegrationUiIntegrationsByTargetPost
 * <br>You must have this scope: 'integration:ui-integrations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param target
 * @return ApiIntegrationUiIntegrationsByTargetPostRequest
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsByTargetPost(ctx _context.Context, target string) ApiIntegrationUiIntegrationsByTargetPostRequest {
	return ApiIntegrationUiIntegrationsByTargetPostRequest{
		ApiService: a,
		ctx: ctx,
		target: target,
	}
}

/*
 * Execute executes the request
 * @return UiIntegrationCreatedModel
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsByTargetPostExecute(r ApiIntegrationUiIntegrationsByTargetPostRequest) (UiIntegrationCreatedModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UiIntegrationCreatedModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiIntegrationsApiService.IntegrationUiIntegrationsByTargetPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/ui-integrations/{target}"
	localVarPath = strings.Replace(localVarPath, "{"+"target"+"}", _neturl.PathEscape(parameterToString(r.target, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationUiIntegrationsGetRequest struct {
	ctx _context.Context
	ApiService *UiIntegrationsApiService
}


func (r ApiIntegrationUiIntegrationsGetRequest) Execute() (UiIntegrationListModel, *_nethttp.Response, error) {
	return r.ApiService.IntegrationUiIntegrationsGetExecute(r)
}

/*
 * IntegrationUiIntegrationsGet Method for IntegrationUiIntegrationsGet
 * <br>You must have this scope: 'integration:ui-integrations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiIntegrationUiIntegrationsGetRequest
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsGet(ctx _context.Context) ApiIntegrationUiIntegrationsGetRequest {
	return ApiIntegrationUiIntegrationsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return UiIntegrationListModel
 */
func (a *UiIntegrationsApiService) IntegrationUiIntegrationsGetExecute(r ApiIntegrationUiIntegrationsGetRequest) (UiIntegrationListModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UiIntegrationListModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UiIntegrationsApiService.IntegrationUiIntegrationsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integration/v1/ui-integrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
